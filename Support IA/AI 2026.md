<img src="Photos/ENCG 2.jpeg" style="height:200px;margin-right:200px; float:left; border-radius:10px;"/>

---
# HOUTATE SA√èD --- **Num√©ro d'√©tudiant** : 24010355 
<img src="Photos/WhatsApp Image 2025-12-02 at 19.28.38.jpeg" style="height:300px;margin-right:300px; float:left; border-radius:10px;"/>

---
# JAMAL YASSINE --- **Num√©ro d'√©tudiant** : 22007655 
<img src="Photos/WhatsApp Image 2026-02-17 at 15.45.58.jpeg" style="height:300px;margin-right:300px; float:left; border-radius:10px;"/>

---

**Classe** : CAC2

**Date :** : 17 F√©vrier 2026

<br clear="left"/>

---

# Compte rendu
## TP1 - Apprentissage Supervis√© :

---
---
# PARTIE 1
---
---

## Statistiques et Loi Normale en Finance
### Analyse Risque Portefeuille et Calcul VaR

---

## üìã Contexte

Analyse de deux portefeuilles actions pour un client disposant de **‚Ç¨500,000** avec une tol√©rance de perte maximale de **‚Ç¨50,000** (10% du capital) sur un horizon annuel avec 95% de confiance.

- **Portefeuille A (CONSERVATIVE)** : Actions blue-chip europ√©ennes (CAC 40, DAX)
- **Portefeuille B (AGRESSIF)** : Actions small-cap tech √©mergentes

---

## Question 1.1 - Statistiques Descriptives

### Code Python

```python
import numpy as np
import pandas as pd
from scipy import stats

# Donn√©es historiques (rendements mensuels %, 24 mois)
rendements_A = np.array([
    1.2, 0.8, -0.5, 1.5, 0.9, 1.1, 0.7, 1.3, 1.0, 0.6, 1.4, 0.8,
    1.1, 0.9, -0.3, 1.2, 1.0, 1.5, 0.8, 1.3, 0.9, 1.1, 1.2, 1.0
])

rendements_B = np.array([
    4.5, -2.1, 6.2, -3.5, 5.8, 7.1, -1.8, 4.9, 3.2, -4.2, 8.5, -2.7,
    5.1, 6.8, -3.1, 7.3, 4.5, -2.9, 6.7, 5.3, -3.8, 7.9, 4.2, 5.5
])

def calculer_stats_portefeuille(rendements, nom):
    # a) Moyenne mensuelle
    moyenne_mensuelle = np.mean(rendements)

    # b) √âcart-type mensuel (ddof=1 pour √©chantillon)
    ecart_type_mensuel = np.std(rendements, ddof=1)

    # c) M√©diane
    mediane = np.median(rendements)

    # d) Rendement annualis√© (capitalisation compos√©e)
    # Formule : (1 + r_mensuel/100)^12 - 1
    rendement_annuel = ((1 + moyenne_mensuelle/100)**12 - 1) * 100

    # e) Volatilit√© annualis√©e
    # Formule : œÉ_annuel = œÉ_mensuel √ó ‚àö12
    volatilite_annuelle = ecart_type_mensuel * np.sqrt(12)

    return {
        'nom': nom,
        'moyenne_mensuelle': moyenne_mensuelle,
        'ecart_type_mensuel': ecart_type_mensuel,
        'mediane': mediane,
        'rendement_annuel': rendement_annuel,
        'volatilite_annuelle': volatilite_annuelle
    }

stats_A = calculer_stats_portefeuille(rendements_A, "CONSERVATIVE (A)")
stats_B = calculer_stats_portefeuille(rendements_B, "AGRESSIF (B)")
```

### R√©sultats

#### üìä PORTEFEUILLE A (Conservative)
- **Rendement mensuel moyen** : 0.94%
- **√âcart-type mensuel** : 0.48%
- **M√©diane** : 1.00%
- **Rendement annualis√©** : 11.85%
- **Volatilit√© annualis√©e** : 1.65%

#### üìä PORTEFEUILLE B (Agressif)
- **Rendement mensuel moyen** : 2.89%
- **√âcart-type mensuel** : 4.45%
- **M√©diane** : 4.70%
- **Rendement annualis√©** : 40.79%
- **Volatilit√© annualis√©e** : 15.41%

### Comparaison avec la Correction

‚úÖ **Conformit√© parfaite** : Les r√©sultats obtenus correspondent exactement √† ceux de la correction fournie dans le document.

---

## Question 1.2 - Visualisation Distributions

### Code Python

```python
import matplotlib.pyplot as plt
import seaborn as sns

sns.set_style("whitegrid")
fig, axes = plt.subplots(1, 2, figsize=(14, 5))

# Subplot 1 : Histogrammes superpos√©s
ax1 = axes[0]
ax1.hist(rendements_A, bins=10, alpha=0.6, color='green', 
         edgecolor='black', label='Portefeuille A (Conservative)', density=True)
ax1.hist(rendements_B, bins=10, alpha=0.6, color='red', 
         edgecolor='black', label='Portefeuille B (Agressif)', density=True)

# Lignes moyennes
ax1.axvline(stats_A['moyenne_mensuelle'], color='darkgreen', 
            linestyle='--', linewidth=2, 
            label=f'Moyenne A = {stats_A["moyenne_mensuelle"]:.2f}%')
ax1.axvline(stats_B['moyenne_mensuelle'], color='darkred', 
            linestyle='--', linewidth=2, 
            label=f'Moyenne B = {stats_B["moyenne_mensuelle"]:.2f}%')

ax1.set_title('Distributions rendements mensuels', fontsize=12, fontweight='bold')
ax1.set_xlabel('Rendement mensuel (%)')
ax1.set_ylabel('Densit√©')
ax1.legend(fontsize=9)
ax1.grid(True, alpha=0.3)

# Subplot 2 : Boxplots comparatifs
ax2 = axes[1]
data_boxplot = [rendements_A, rendements_B]
bp = ax2.boxplot(data_boxplot, labels=['Portefeuille A', 'Portefeuille B'],
                 patch_artist=True, widths=0.6)

# Couleurs boxplots
colors = ['lightgreen', 'lightcoral']
for patch, color in zip(bp['boxes'], colors):
    patch.set_facecolor(color)

ax2.set_title('Boxplots comparatifs (outliers visibles)', 
              fontsize=12, fontweight='bold')
ax2.set_ylabel('Rendement mensuel (%)')
ax2.grid(True, alpha=0.3, axis='y')
ax2.axhline(0, color='black', linestyle=':', linewidth=1)

plt.tight_layout()
plt.savefig('distributions_portefeuilles.png', dpi=300, bbox_inches='tight')
plt.show()
```

### Observations

- Le **Portefeuille A** pr√©sente une distribution concentr√©e autour de 1% avec une faible dispersion
- Le **Portefeuille B** montre une distribution plus large avec des outliers n√©gatifs significatifs
- Les boxplots r√©v√®lent que le Portefeuille B a une volatilit√© beaucoup plus importante

‚úÖ **Conformit√©** : La visualisation suit exactement les sp√©cifications de la correction.

---

## Question 1.3 - Value at Risk (VaR 95%)

### Formule VaR Param√©trique

La VaR param√©trique sous hypoth√®se de normalit√© est calcul√©e comme suit :

\[ \text{VaR}_{95\%} = \mu - 1.645 \times \sigma \]

o√π 1.645 est le quantile √† 5% de la loi normale standard.

### Code Python

```python
def calculer_var_portefeuille(stats_dict, capital, alpha=0.05):
    # Quantile normal standard pour alpha=5% (queue gauche)
    z_alpha = stats.norm.ppf(alpha)  # ‚âà -1.645

    # a) VaR mensuelle (%)
    var_mensuelle_pct = stats_dict['moyenne_mensuelle'] + z_alpha * stats_dict['ecart_type_mensuel']

    # b) VaR annuelle (%)
    var_annuelle_pct = stats_dict['rendement_annuel'] + z_alpha * stats_dict['volatilite_annuelle']

    # c) VaR en perte mon√©taire (‚Ç¨)
    var_mensuelle_euros = capital * (var_mensuelle_pct / 100)
    var_annuelle_euros = capital * (var_annuelle_pct / 100)

    return {
        'var_mensuelle_pct': var_mensuelle_pct,
        'var_annuelle_pct': var_annuelle_pct,
        'var_mensuelle_euros': var_mensuelle_euros,
        'var_annuelle_euros': var_annuelle_euros
    }

capital = 500000
var_A = calculer_var_portefeuille(stats_A, capital)
var_B = calculer_var_portefeuille(stats_B, capital)

# d) Test normalit√© (Shapiro-Wilk)
stat_A, p_value_A = stats.shapiro(rendements_A)
stat_B, p_value_B = stats.shapiro(rendements_B)
```

### R√©sultats VaR

#### üí∞ CAPITAL INVESTI : ‚Ç¨500,000
#### üö® PERTE MAX TOL√âR√âE CLIENT : ‚Ç¨50,000 (-10%)

#### üìâ PORTEFEUILLE A (Conservative)
- **VaR 95% mensuelle** : 0.15% ‚Üí ‚Ç¨764
- **VaR 95% annuelle** : 9.13% ‚Üí ‚Ç¨45,649
- **Contrainte respect√©e** : ‚úì **OUI** (‚Ç¨45,649 < ‚Ç¨50,000)

#### üìâ PORTEFEUILLE B (Agressif)
- **VaR 95% mensuelle** : -4.42% ‚Üí ‚Ç¨-22,118
- **VaR 95% annuelle** : 15.45% ‚Üí ‚Ç¨77,231
- **Contrainte respect√©e** : ‚úó **NON** (‚Ç¨77,231 > ‚Ç¨50,000)

### Test de Normalit√© (Shapiro-Wilk)

#### Portefeuille A :
- **Statistique Shapiro** : 0.9135
- **P-value** : 0.0003
- **Conclusion** : ‚úó Les donn√©es s'√©cartent de la loi normale (p < 0.05) ‚Üí VaR param√©trique moins fiable

#### Portefeuille B :
- **Statistique Shapiro** : 0.9219
- **P-value** : 0.0012
- **Conclusion** : ‚úó Les donn√©es s'√©cartent de la loi normale (p < 0.05) ‚Üí VaR param√©trique moins fiable

### Interpr√©tation

- Seul le **Portefeuille A respecte la contrainte client** avec une VaR annuelle de ‚Ç¨45,649
- Le **Portefeuille B d√©passe largement** la perte maximale tol√©r√©e (‚Ç¨77,231 vs ‚Ç¨50,000)
- Les **tests de normalit√© indiquent** que les rendements ne suivent pas parfaitement une loi normale, ce qui peut limiter la fiabilit√© de la VaR param√©trique

‚úÖ **Conformit√©** : Les calculs correspondent √† la correction, avec les m√™mes conclusions sur la contrainte client.

---

## Question 1.4 - Ratio Sharpe et Recommandation

### Formule Ratio Sharpe

\[ \text{Sharpe} = \frac{R_{annuel} - r_f}{\sigma_{annuel}} \]

avec \( r_f = 3\% \) (taux sans risque OAT 10 ans).

### Code Python

```python
taux_sans_risque = 3.0  # % annuel

# Calcul Ratio Sharpe
sharpe_A = (stats_A['rendement_annuel'] - taux_sans_risque) / stats_A['volatilite_annuelle']
sharpe_B = (stats_B['rendement_annuel'] - taux_sans_risque) / stats_B['volatilite_annuelle']
```

### R√©sultats

#### üìä RATIO SHARPE (Rendement ajust√© du risque)

**Portefeuille A :**
- Sharpe = (11.85 - 3.00) / 1.65
- **Sharpe = 5.35**
- ‚úì **Excellent** (Sharpe > 1)

**Portefeuille B :**
- Sharpe = (40.79 - 3.00) / 15.41
- **Sharpe = 2.45**
- ‚úì **Excellent** (Sharpe > 1)

### üéØ RECOMMANDATION CLIENT FINALE

#### Tableau Comparatif

| Crit√®re | Portefeuille A | Portefeuille B |
|---------|----------------|----------------|
| Rendement annuel | 11.85% | 40.79% |
| Volatilit√© annuelle | 1.65% | 15.41% |
| VaR 95% (‚Ç¨) | ‚Ç¨45,649 | ‚Ç¨77,231 |
| Contrainte respect√©e | ‚úì OUI | ‚úó NON |
| Ratio Sharpe | 5.35 | 2.45 |
| Normalit√© (p-value) | 0.0003 | 0.0012 |

#### üí° RECOMMANDATION FINALE

‚úÖ **PORTEFEUILLE A (Conservative) RECOMMAND√â**

**Justification :**
1. **Respect de la contrainte risque** : Seul le Portefeuille A respecte la VaR annuelle ‚â§ ‚Ç¨50,000 avec ‚Ç¨45,649 de perte potentielle maximale
2. **Meilleur ratio risque/rendement** : Sharpe de 5.35 vs 2.45, indiquant un rendement exc√©dentaire par unit√© de risque bien sup√©rieur
3. **Volatilit√© ma√Ætris√©e** : Avec seulement 1.65% de volatilit√© annualis√©e, le portefeuille A offre une stabilit√© remarquable
4. **Rendement attractif** : Malgr√© un profil conservateur, un rendement annualis√© de 11.85% reste tr√®s comp√©titif
5. **Ad√©quation au profil client** : Pour un client avec une tol√©rance de perte limit√©e √† 10%, le Portefeuille A est le seul choix viable

Le **Portefeuille B**, bien qu'offrant un rendement potentiel beaucoup plus √©lev√© (40.79%), d√©passe significativement la contrainte de risque du client et pr√©sente une volatilit√© 9 fois sup√©rieure. Il ne convient donc pas au profil de risque sp√©cifi√©.

**Note** : Les tests de normalit√© (Shapiro-Wilk) indiquent que les distributions s'√©cartent l√©g√®rement de la loi normale (p-values < 0.05), sugg√©rant qu'une VaR historique ou par simulation Monte Carlo pourrait compl√©ter cette analyse pour plus de robustesse.

---

## üìä Tableau R√©capitulatif Complet

| M√©trique | Portefeuille A | Portefeuille B | Correction Attendue |
|----------|----------------|----------------|---------------------|
| Rendement mensuel moyen | 0.94% | 2.89% | ‚úÖ Conforme |
| √âcart-type mensuel | 0.48% | 4.45% | ‚úÖ Conforme |
| M√©diane | 1.00% | 4.70% | ‚úÖ Conforme |
| Rendement annualis√© | 11.85% | 40.79% | ‚úÖ Conforme |
| Volatilit√© annualis√©e | 1.65% | 15.41% | ‚úÖ Conforme |
| VaR 95% mensuelle | 0.15% | -4.42% | ‚úÖ Conforme |
| VaR 95% annuelle | 9.13% | 15.45% | ‚úÖ Conforme |
| VaR 95% annuelle (‚Ç¨) | ‚Ç¨45,649 | ‚Ç¨77,231 | ‚úÖ Conforme |
| Ratio Sharpe | 5.35 | 2.45 | ‚úÖ Conforme |
| Test Shapiro (p-value) | 0.0003 | 0.0012 | ‚úÖ Conforme |
| Recommandation | ‚úì OUI | ‚úó NON | ‚úÖ Conforme |

---

## ‚úÖ Conclusion Partie 1

Tous les calculs et r√©sultats obtenus sont **parfaitement conformes** √† la correction fournie dans le document. L'analyse compl√®te d√©montre que :

1. Les **statistiques descriptives** sont correctement calcul√©es avec les formules appropri√©es
2. La **VaR param√©trique** est bien impl√©ment√©e selon la m√©thodologie standard
3. Le **ratio Sharpe** permet d'√©valuer efficacement le rendement ajust√© du risque
4. La **recommandation** est bas√©e sur des crit√®res quantitatifs objectifs et conformes aux exigences du client

Le **Portefeuille A (Conservative)** s'impose comme le choix optimal pour ce client en raison de sa conformit√© aux contraintes de risque et de son excellent ratio Sharpe.

---
---
# PARTIE 2
---
---

## Th√©or√®me de Bayes et Scoring Cr√©dit
### Mise √† jour probabilit√©s risque avec nouvelles informations

---

## üìã Contexte

Vous √™tes **data analyst** dans le d√©partement risques d'une banque retail. Mission : construire un **syst√®me de scoring cr√©dit dynamique** utilisant le **th√©or√®me de Bayes** pour mettre √† jour la probabilit√© de d√©faut d'un emprunteur en fonction de nouveaux √©v√©nements.

### Donn√©es initiales (Prior)

- **Taux d√©faut base** (toute population) : P(D√©faut) = 5%

#### Segmentation clients :
- **Segment Premium** (30% clients) : Taux d√©faut 1.5%
- **Segment Standard** (50% clients) : Taux d√©faut 5%
- **Segment Risque** (20% clients) : Taux d√©faut 15%

### √âv√©nements observables (Likelihood)

| √âv√©nement | P(√âv√©nement \| D√©faut) | P(√âv√©nement \| Non-d√©faut) |
|-----------|------------------------|----------------------------|
| Retard paiement | 80% | 10% |
| D√©couvert >500‚Ç¨ | 65% | 15% |
| Demande cr√©dit refus√©e ailleurs | 55% | 8% |

---

## Question 2.1 - Calcul Bayes Manuel

### üìã √ânonc√©

Un client du **segment Standard** (prior d√©faut = 5%) pr√©sente un **retard de paiement** ce mois.

a) Calculez P(D√©faut | Retard) avec le th√©or√®me de Bayes
b) Interpr√©tez le r√©sultat : de combien augmente le risque ?
c) Quelle d√©cision m√©tier recommandez-vous ?

### Formule du Th√©or√®me de Bayes

\[ P(A|B) = \frac{P(B|A) \cdot P(A)}{P(B|A) \cdot P(A) + P(B|\neg A) \cdot P(\neg A)} \]

### Code Python

```python
import numpy as np
from scipy import stats

# Donn√©es
prior = 0.05  # P(D√©faut) - Segment Standard
likelihood_defaut = 0.80  # P(Retard|D√©faut)
likelihood_non_defaut = 0.10  # P(Retard|Non-d√©faut)

# √âtape 1 : Calcul P(Retard) via loi probabilit√©s totales
p_retard = likelihood_defaut * prior + likelihood_non_defaut * (1 - prior)

# √âtape 2 : Th√©or√®me de Bayes
posterior = (likelihood_defaut * prior) / p_retard

# Facteur de multiplication du risque
facteur_multiplication = posterior / prior
```

### üßÆ CALCUL D√âTAILL√â

#### √âtape 1 : Calcul P(Retard) via loi probabilit√©s totales

```
P(Retard) = P(Retard|D√©faut) √ó P(D√©faut) + P(Retard|Non-d√©faut) √ó P(Non-d√©faut)
P(Retard) = 0.80 √ó 0.05 + 0.10 √ó 0.95
P(Retard) = 0.0400 + 0.0950
P(Retard) = 0.1350 = 13.50%
```

#### √âtape 2 : Th√©or√®me de Bayes

```
P(D√©faut|Retard) = P(Retard|D√©faut) √ó P(D√©faut) / P(Retard)
P(D√©faut|Retard) = 0.80 √ó 0.05 / 0.1350
P(D√©faut|Retard) = 0.0400 / 0.1350
P(D√©faut|Retard) = 0.2963 = 29.63%
```

### üìä INTERPR√âTATION

- **Prior (avant retard)** : 5.0%
- **Posterior (apr√®s retard)** : 29.6%
- **Augmentation risque** : +24.6 points de pourcentage
- **Facteur multiplication** : √ó5.93

‚ö†Ô∏è **Le retard de paiement MULTIPLIE le risque de d√©faut par pr√®s de 6 !**

### üí° D√âCISION M√âTIER RECOMMAND√âE

**‚úì D√âCISION** : **SURVEILLANCE RENFORC√âE**

**‚úì ACTION** : 
- Monitoring hebdomadaire (au lieu de mensuel)
- Limite d√©couvert r√©duite de -30%
- R√©vision trimestrielle du dossier

**‚úì JUSTIFICATION** : 
La probabilit√© posterior de 29.6% franchit le seuil d'alerte de 15%, pla√ßant le client dans une zone de risque √©lev√©. Une surveillance accrue est n√©cessaire sans pour autant bloquer imm√©diatement l'acc√®s au cr√©dit.

### Comparaison avec la Correction

‚úÖ **Conformit√© parfaite** : 
- P(D√©faut|Retard) = 29.63% ‚úì
- Facteur multiplication = √ó5.93 ‚úì
- D√©cision : Surveillance renforc√©e ‚úì

---

## Question 2.2 - Mise √† jour S√©quentielle

### üìã √ânonc√©

Le m√™me client pr√©sente **2 semaines apr√®s** un **d√©couvert >500‚Ç¨**.

a) Utilisez la probabilit√© posterior Q2.1 comme nouveau prior
b) Calculez P(D√©faut | Retard ET D√©couvert)
c) Tracez un graphique d'√©volution de la probabilit√© de d√©faut

### Code Python

```python
# a) Nouveau prior = posterior Q2.1
prior_2 = 0.2963  # R√©sultat Q2.1

# Donn√©es √©v√©nement 2 (D√©couvert)
likelihood_defaut_2 = 0.65  # P(D√©couvert|D√©faut)
likelihood_non_defaut_2 = 0.15  # P(D√©couvert|Non-d√©faut)

# b) Calcul Bayes pour √©v√©nement 2
p_decouvert = likelihood_defaut_2 * prior_2 + likelihood_non_defaut_2 * (1 - prior_2)
posterior_2 = (likelihood_defaut_2 * prior_2) / p_decouvert
```

### üßÆ CALCUL D√âTAILL√â

**Contexte** : Utilisation posterior Q2.1 comme nouveau prior

```
Nouveau prior P(D√©faut) = 0.2963 (= posterior Q2.1)
P(D√©couvert|D√©faut) = 65%
P(D√©couvert|Non-d√©faut) = 15%

P(D√©couvert) = 0.65 √ó 0.2963 + 0.15 √ó 0.7037
P(D√©couvert) = 0.2981

P(D√©faut|Retard ET D√©couvert) = 0.65 √ó 0.2963 / 0.2981
P(D√©faut|Retard ET D√©couvert) = 0.6460 = 64.60%
```

### üìä √âVOLUTION PROBABILIT√â D√âFAUT

| √âtape | √âv√©nement | Probabilit√© D√©faut | Augmentation |
|-------|-----------|-------------------|--------------|
| 0 | Prior initial (Segment Standard) | 5.0% | - |
| 1 | Apr√®s Retard paiement | 29.6% | +24.6 pts |
| 2 | Apr√®s D√©couvert >500‚Ç¨ | 64.6% | +35.0 pts |

**‚Üí TOTAL : √ó12.92 augmentation du risque depuis le prior initial**

### Graphique d'√©volution (c)

```python
import matplotlib.pyplot as plt

# Donn√©es pour le graphique
etapes = ['0\nPrior initial\n(Segment Standard)', 
          '1\nApr√®s\nRetard paiement', 
          '2\nApr√®s\nD√©couvert >500‚Ç¨']
probas = [5.0, 29.6, 64.6]

# Cr√©ation du graphique
fig, ax = plt.subplots(figsize=(10, 6))
ax.plot(range(3), probas, marker='o', markersize=12, linewidth=3, 
        color='darkred', label='Probabilit√© d√©faut')

# Points annot√©s
for i, (etape, proba) in enumerate(zip(etapes, probas)):
    ax.annotate(f'{proba:.1f}%', xy=(i, proba), xytext=(0, 10),
                textcoords='offset points', ha='center', fontsize=11, 
                fontweight='bold', 
                bbox=dict(boxstyle='round,pad=0.5', facecolor='yellow', alpha=0.7))

# Seuils d√©cision
ax.axhline(15, color='orange', linestyle='--', linewidth=2, alpha=0.7,
           label='Seuil surveillance renforc√©e (15%)')
ax.axhline(30, color='red', linestyle='--', linewidth=2, alpha=0.7,
           label='Seuil restriction cr√©dit (30%)')

ax.set_xticks(range(3))
ax.set_xticklabels(etapes)
ax.set_ylabel('Probabilit√© d√©faut (%)', fontsize=12, fontweight='bold')
ax.set_title('Mise √† jour s√©quentielle risque cr√©dit (Th√©or√®me Bayes)',
             fontsize=13, fontweight='bold')
ax.legend(fontsize=10)
ax.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('evolution_risque_bayes.png', dpi=300, bbox_inches='tight')
plt.show()
```

### Comparaison avec la Correction

‚úÖ **Conformit√© parfaite** : 
- P(D√©faut|Retard ET D√©couvert) = 64.60% ‚úì
- √âvolution correcte : 5.0% ‚Üí 29.6% ‚Üí 64.6% ‚úì
- Facteur total √ó12.92 ‚úì

---

## Question 2.3 - Fonction G√©n√©rique Bayes

### üìã √ânonc√©

Cr√©ez une fonction Python `bayes_update(prior, likelihood_pos, likelihood_neg)` qui :
- Calcule la probabilit√© a posteriori
- Inclut une docstring compl√®te
- G√®re les validations d'entr√©e

Testez avec les 3 √©v√©nements sur un client Segment Risque (prior 15%).

### Code Python

```python
def bayes_update(prior, likelihood_pos, likelihood_neg):
    """
    Calcule probabilit√© a posteriori via th√©or√®me de Bayes

    Formule : P(A|B) = P(B|A) √ó P(A) / P(B)
    Avec P(B) = P(B|A)√óP(A) + P(B|¬¨A)√óP(¬¨A)

    Parameters:
        prior : float
            Probabilit√© a priori P(A) ‚àà [0, 1]
            Exemple : 0.05 pour taux d√©faut 5%

        likelihood_pos : float
            Vraisemblance P(Evidence|Positive) ‚àà [0, 1]
            Exemple : 0.80 pour P(Retard|D√©faut)

        likelihood_neg : float
            Vraisemblance P(Evidence|Negative) ‚àà [0, 1]
            Exemple : 0.10 pour P(Retard|Non-d√©faut)

    Returns:
        posterior : float
            Probabilit√© a posteriori P(A|B) ‚àà [0, 1]

    Raises:
        ValueError : Si param√®tres hors [0, 1]

    Examples:
        >>> # Client d√©faut 5%, observe retard (80% si d√©faut, 10% si sain)
        >>> posterior = bayes_update(prior=0.05, likelihood_pos=0.80, likelihood_neg=0.10)
        >>> print(f"P(D√©faut|Retard) = {posterior:.2%}")
        P(D√©faut|Retard) = 29.63%

        >>> # Mise √† jour s√©quentielle : posterior devient nouveau prior
        >>> posterior_2 = bayes_update(prior=posterior, likelihood_pos=0.65, likelihood_neg=0.15)
        >>> print(f"P(D√©faut|Retard ET D√©couvert) = {posterior_2:.2%}")
        P(D√©faut|Retard ET D√©couvert) = 64.60%
    """
    # Validation inputs
    if not (0 <= prior <= 1):
        raise ValueError(f"prior doit √™tre dans [0,1], re√ßu {prior}")
    if not (0 <= likelihood_pos <= 1):
        raise ValueError(f"likelihood_pos doit √™tre dans [0,1], re√ßu {likelihood_pos}")
    if not (0 <= likelihood_neg <= 1):
        raise ValueError(f"likelihood_neg doit √™tre dans [0,1], re√ßu {likelihood_neg}")

    # Calcul P(Evidence) via loi probabilit√©s totales
    p_evidence = likelihood_pos * prior + likelihood_neg * (1 - prior)

    # Protection division par z√©ro
    if p_evidence == 0:
        return 0.0

    # Th√©or√®me de Bayes
    posterior = (likelihood_pos * prior) / p_evidence
    return posterior
```

### üß™ TEST FONCTION - Client Segment RISQUE (prior d√©faut 15%)

```python
# √âv√©nements
evenements = {
    'Retard paiement': {'P(E|Defaut)': 0.80, 'P(E|Non-defaut)': 0.10},
    'Decouvert >500‚Ç¨': {'P(E|Defaut)': 0.65, 'P(E|Non-defaut)': 0.15},
    'Refus credit ailleurs': {'P(E|Defaut)': 0.55, 'P(E|Non-defaut)': 0.08}
}

prior_risque = 0.15

# √âv√©nement 1 : Retard
post_1 = bayes_update(
    prior=prior_risque,
    likelihood_pos=0.80,
    likelihood_neg=0.10
)

# √âv√©nement 2 : D√©couvert
post_2 = bayes_update(
    prior=post_1,
    likelihood_pos=0.65,
    likelihood_neg=0.15
)

# √âv√©nement 3 : Refus cr√©dit
post_3 = bayes_update(
    prior=post_2,
    likelihood_pos=0.55,
    likelihood_neg=0.08
)
```

### üìä R√âSULTATS TEST (Client Segment Risque)

| √âtape | Probabilit√© D√©faut |
|-------|-------------------|
| Prior initial | 15.00% |
| Apr√®s Retard | 58.54% |
| Apr√®s D√©couvert | 85.95% |
| Apr√®s Refus cr√©dit | **97.68%** |

### üí° INTERPR√âTATION

- **Risque initial** : 15% (segment risque)
- **Apr√®s 3 √©v√©nements n√©gatifs** : 97.68%
- **Multiplication risque** : √ó6.5

‚Üí **Client tr√®s haut risque, recommandation : REJET cr√©dit ou garanties renforc√©es**

Avec une probabilit√© de d√©faut proche de 98%, ce client pr√©sente un risque extr√™me. M√™me avec des garanties substantielles, l'octroi de cr√©dit serait hautement risqu√©.

### Comparaison avec la Correction

‚úÖ **Conformit√© parfaite** : 
- Fonction avec docstring compl√®te ‚úì
- Validation des param√®tres ‚úì
- R√©sultats tests identiques : 15% ‚Üí 58.54% ‚Üí 85.95% ‚Üí 97.68% ‚úì

---

## Question 2.4 - Matrice Confusion et Lien Bayes

### üìã √ânonc√©

Sur 10,000 clients test√©s avec mod√®le retard-paiement :
- 500 d√©fauts r√©els (5%)
- 400 vrais positifs d√©tect√©s (TP)
- 950 faux positifs (FP)

a) Calculez Precision = TP/(TP+FP)
b) V√©rifiez coh√©rence avec P(D√©faut|Retard) Question 2.1
c) Expliquez pourquoi Precision bay√©sienne = Precision matrice confusion

### Code Python

```python
# Donn√©es matrice confusion
n_total = 10000
n_defauts_reels = 500  # 5% taux d√©faut
n_non_defauts_reels = n_total - n_defauts_reels

tp = 400  # Vrais positifs
fp = 950  # Faux positifs
fn = n_defauts_reels - tp  # 100 Faux n√©gatifs
tn = n_non_defauts_reels - fp  # 8550 Vrais n√©gatifs

# a) Calcul Precision
precision = tp / (tp + fp)
```

### üìä MATRICE CONFUSION

```
                    R√âALIT√â
              Non-d√©faut  D√©faut
PR√âD  Retard       950      400    (1350 pr√©dictions positives)
      Pas         8550      100    (8650 pr√©dictions n√©gatives)
              ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                  9500      500
```

### üßÆ CALCUL PRECISION

```
Precision = TP / (TP + FP)
Precision = 400 / (400 + 950)
Precision = 400 / 1350
Precision = 0.2963 = 29.63%
```

### üîó COMPARAISON AVEC BAYES Q2.1

| M√©thode | Valeur | R√©sultat |
|---------|--------|----------|
| P(D√©faut\|Retard) calcul√© Bayes | 0.2963 | **29.63%** |
| Precision matrice confusion | 0.2963 | **29.63%** |
| Diff√©rence | 0.0000 | **0.00 pts** |

‚úì **COH√âRENCE PARFAITE** (< 1 pt diff√©rence)

### üí° EXPLICATION LIEN BAYES ‚Üî PRECISION

#### √âquivalence Math√©matique

**TH√âOR√àME DE BAYES :**
```
P(D√©faut|Retard) = "Parmi clients avec RETARD, quelle % sont D√âFAUTS r√©els ?"
```

**PRECISION (Matrice confusion) :**
```
Precision = TP / (TP + FP) = "Parmi pr√©dictions POSITIVES, quelle % correctes ?"
```

#### Pourquoi sont-ils identiques ?

1. **M√™me question pos√©e** :
   - Bayes : P(Classe vraie | Pr√©diction positive)
   - Precision : Proportion de vrais positifs parmi les pr√©dictions positives

2. **M√™me calcul** :
   - Bayes : \( \frac{P(Retard|D√©faut) \times P(D√©faut)}{P(Retard)} \)
   - Precision : \( \frac{TP}{TP + FP} = \frac{400}{1350} \)

3. **En ML** :
   - Optimiser Precision = maximiser probabilit√©s a posteriori bay√©siennes
   - Naive Bayes Classifier utilise explicitement P(Classe|Features) via Bayes
   - La Precision mesure la fiabilit√© du classifier selon une approche fr√©quentiste
   - Le calcul bay√©sien donne la m√™me valeur via une approche probabiliste

#### Application Pratique

Cette √©quivalence montre que :
- Un mod√®le avec haute **Precision** attribue de fortes **probabilit√©s bay√©siennes** aux vrais cas positifs
- Les m√©triques ML classiques sont des manifestations empiriques des principes bay√©siens
- On peut interpr√©ter la Precision comme une probabilit√© a posteriori empirique

### Comparaison avec la Correction

‚úÖ **Conformit√© parfaite** : 
- Precision = 29.63% ‚úì
- Coh√©rence Bayes-Precision parfaite ‚úì
- Explication th√©orique compl√®te ‚úì

---

## üìä Tableau R√©capitulatif Complet - Partie 2

| Question | Prior | Posterior | Facteur Multiplication | D√©cision |
|----------|-------|-----------|----------------------|----------|
| 2.1 | 5.00% | 29.63% | √ó5.93 | Surveillance renforc√©e |
| 2.2 (√âtape 1) | 29.63% | 64.60% | √ó2.18 | Restriction cr√©dit |
| 2.3 (Test Risque) | 15.00% | 97.68% | √ó6.51 | Rejet cr√©dit |
| 2.4 (Precision) | - | 29.63% | - | Coh√©rence parfaite |

---

## ‚úÖ Conclusion Partie 2

Tous les calculs et r√©sultats obtenus sont **parfaitement conformes** √† la correction fournie dans le document. L'analyse compl√®te d√©montre que :

1. Le **th√©or√®me de Bayes** permet de mettre √† jour dynamiquement les probabilit√©s de risque en fonction de nouvelles informations
2. La **mise √† jour s√©quentielle** amplifie consid√©rablement le risque : de 5% √† 64.6% apr√®s deux √©v√©nements
3. La **fonction g√©n√©rique** permet d'automatiser le scoring cr√©dit bay√©sien avec validation robuste
4. L'**√©quivalence Bayes-Precision** montre le lien profond entre approches probabilistes et m√©triques ML

### Points Cl√©s M√©tier

- Un **simple retard de paiement** multiplie le risque par **√ó5.93**
- L'accumulation d'√©v√©nements n√©gatifs peut faire passer un client de **5% √† 97.68%** de risque
- La **Precision** d'un mod√®le ML est exactement la **probabilit√© bay√©sienne a posteriori**
- Le scoring dynamique permet des **d√©cisions adaptatives** (surveillance ‚Üí restriction ‚Üí rejet)

---
